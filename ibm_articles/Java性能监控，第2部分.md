# Java 性能监控，第 2 部分
利用 JDK 内置分析器进行 Java 进程监控

**标签:** Java

[原文链接](https://developer.ibm.com/zh/articles/j-5things8/)

Ted Neward, Alex Theedom

发布: 2010-09-03

* * *

##### 关于该系列

您觉得自己懂 Java 编程？事实上，大多数程序员对于 Java 平台都是浅尝辄止，只学习了足以完成手头上任务的知识而已。在 [本系列中](/zh/series/5-things-you-didnt-know-about/)，Ted Neward Ted Neward 深入挖掘 Java 平台的核心功能，揭示一些鲜为人知的事实，帮助您解决最棘手的编程困难。

全功能内置分析器，如 JConsole 和 VisualVM 的成本有时比它们的性能费用还要高 — 尤其是在生产软件上运行的系统中。因此，在聚焦 Java 性能监控的第 2 篇文章中，我将介绍 5 个命令行分析工具，使开发人员仅关注运行的 Java 进程的一个方面。

JDK 包括很多命令行实用程序，可以用于监控和管理 Java 应用程序性能。虽然大多数这类应用程序都被标注为 “实验型”，在技术上不受支持，但是它们很有用。有些甚至是特定用途工具的种子材料，可以使用 JVMTI 或 JDI（参见 参考资料 ）建立。

## 1\. jps (sun.tools.jps)

很多命令行工具都要求您识别您希望监控的 Java 进程。这与监控本地操作系统进程、同样需要一个程序识别器的同类工具没有太大区别。

“VMID” 识别器与本地操作系统进程识别器（”pid”）并不总是相同的，这就是我们需要 JDK `jps` 实用程序的原因。

##### 在 Java 进程中使用 jps

与配置 JDK 的大部分工具及本文中提及的所有工具一样，可执行 `jps` 通常是一个围绕 Java 类或执行大多数工作的类集的一个薄包装。在 Windows 环境下，这些工具是 .exe 文件，使用 JNI Invocation API 直接调用上面提及的类；在 UNIX 环境下，大多数工具是一个 shell 脚本的符号链接，该脚本采用指定的正确类名称开始一个普通启动程序。

如果您希望在 Java 进程中使用 `jps`（或者任何其他工具）的功能  Ant 脚本  仅在每个工具的 “主” 类上调用 `main()` 相对容易。为了简化引用，类名称出现在每个工具名称之后的括号内。

`jps` — 名称反映了在大多数 UNIX 系统上发现的 `ps` 实用程序 — 告诉我们运行 Java 应用程序的 JVMID。顾名思义， `jps` 返回指定机器上运行的所有已发现的 Java 进程的 VMID。如果 `jps` 没有发现进程，并不意味着无法附加或研究 Java 进程，而只是意味着它并未宣传自己的可用性。

如果发现 Java 进程， `jps` 将列出启用它的命令行。这种区分 Java 进程的方法非常重要，因为只要涉及操作系统，所有的 Java 进程都被统称为 “`java` ”。在大多数情况下，VMID 是值得注意的重要数字。

### 使用分析器开始

使用分析实用程序开始的最简单方法是使用一个如在 `demo/jfc/SwingSet2` 中发现的 SwingSet2 演示一样的演示程序。这样就可以避免程序作为背景/监控程序运行时出现挂起的可能性。当您了解工具及其费用后，就可以在实际程序中进行试用。

加载演示应用程序后，运行 `jps` 并注意返回的 `vmid` 。为了获得更好的效果，采用 `-Dcom.sun.management.jmxremote` 属性集启动 Java 进程。如果没有使用该设置，部分下列工具收集的部分数据可能不可用。

## 2\. jstat (sun.tools.jstat)

`jstat` 实用程序可以用于收集各种各样不同的统计数据。 `jstat` 统计数据被分类到 “选项” 中，这些选项在命令行中被指定作为第一参数。对于 JDK 1.6 来说，您可以通过采用命令 `-options` 运行 `jstat` 查看可用的选项清单。清单 1 中显示了部分选项：

##### 清单 1\. jstat 选项

```
-class
-compiler
-gc
-gccapacity
-gccause
-gcnew
-gcnewcapacity
-gcold
-gcoldcapacity
-gcpermcapacity
-gcutil
-printcompilation

```

Show moreShow more icon

实用程序的 JDK 记录（参见 参考资料 ）将告诉您清单 1 中每个选项返回的内容，但是其中大多数用于收集垃圾的收集器或者其部件的性能信息。 `-class` 选项显示了加载及未加载的类（使其成为检测应用程序服务器或代码中 `ClassLoader` 泄露的重要实用程序，且 `-compiler` 和 `-printcompilation` 都显示了有关 Hotspot JIT 编译程序的信息。

默认情况下， `jstat` 在您核对信息时显示信息。如果您希望每隔一定时间拍摄快照，请在 `-options` 指令后以毫秒为单位指定间隔时间。 `jstat` 将持续显示监控进程信息的快照。如果您希望 `jstat` 在终止前进行特定数量的快照，在间隔时间/时间值后指定该数字。

如果 5756 是几分钟前开始的运行 SwingSet2 程序的 VMID，那么下列命令将告诉 `jstat` 每 250 毫秒为 10 个佚代执行一次 gc 快照转储，然后停止：

```
jstat -gc 5756 250 10

```

Show moreShow more icon

请注意 Sun（现在的 Oracle）保留了在不进行任何预先通知的情况下更改各种选项的输出甚至是选项本身的权利。这是使用不受支持实用程序的缺点。请参看 Javadocs 了解 `jstat` 输出中每一列的全部细节。

## 3\. jstack (sun.tools.jstack)

了解 Java 进程及其对应的执行线程内部发生的情况是一种常见的诊断挑战。例如，当一个应用程序突然停止进程时，很明显出现了资源耗尽，但是仅通过查看代码无法明确知道何处出现资源耗尽，且为什么会发生。

`jstack` 是一个可以返回在应用程序上运行的各种各样线程的一个完整转储的实用程序，您可以使用它查明问题。

采用期望进程的 VMID 运行 `jstack` 会产生一个堆转储。就这一点而言， `jstack` 与在控制台窗口内按 Ctrl-Break 键起同样的作用，在控制台窗口中，Java 进程正在运行或调用 VM 内每个 `Thread` 对象上的 `Thread.getAllStackTraces()` 或 `Thread.dumpStack()` 。 `jstack` 调用也转储关于在 VM 内运行的非 Java 线程的信息，这些线程作为 `Thread` 对象并不总是可用的。

`jstack` 的 `-l` 参数提供了一个较长的转储，包括关于每个 Java 线程持有锁的更多详细信息，因此发现（和 squash）死锁或可伸缩性 bug 是极其重要的。

## 4\. jmap (sun.tools.jmap)

有时，您正在处理的问题是一个对象泄露，如一个 `ArrayList` （可能持有成千上万个对象）该释放时没有释放。另一个更普遍的问题是，看似从不会压缩的扩展堆，却有活跃的垃圾收集。

当您努力寻找一个对象泄露时，在指定时刻对堆及时进行拍照，然后审查其中内容非常有用。 `jmap` 通过对堆拍摄快照来提供该功能的第一部分。然后您可以采用下一部分中描述的 `jhat` 实用程序分析堆数据。

与这里描述的其他所有实用程序一样，使用 `jmap` 非常简单。将 `jmap` 指向您希望拍快照的 Java 进程的 VMID，然后给予它部分参数，用来描述产生的结果文件。您要传递给 `jmap` 的选项包括转储文件的名称以及是否使用一个文本文件或二进制文件。二进制文件是最有用的选项，但是只有当与某一种索引工具 结合使用时 — 通过十六进制值的文本手动操作数百兆字节不是最好的方法。

随意看一下 Java 堆的更多信息， `jmap` 同样支持 `-histo` 选项。 `-histo` 产生一个对象文本柱状图，现在在堆中大量引用，由特定类型消耗的字节总数分类。它同样给出了特定类型的总示例数量，支持部分原始计算，并猜测每个实例的相对成本。

不幸的是， `jmap` 没有像 `jstat` 一样的 period-and-max-count 选项，但是将 `jmap` （或 `jmap.main()` ）调用放入 shell 脚本或其他类的循环，周期性地拍摄快照相对简单。（事实上，这是加入 `jmap` 的一个好的扩展，不管是作为 OpenJDK 本身的源补丁，还是作为其他实用程序的扩展。）

## 5\. jhat (com.sun.tools.hat.Main)

将堆转储至一个二进制文件后，您就可以使用 `jhat` 分析二进制堆转储文件。 `jhat` 创建一个 HTTP/HTML 服务器，该服务器可以在浏览器中被浏览，提供一个关于堆的 object-by-object 视图，及时冻结。根据对象引用草率处理堆可能会非常可笑，您可以通过对总体混乱进行某种自动分析而获得更好的服务。幸运的是， `jhat` 支持 OQL 语法进行这样的分析。

例如，对所有含有超过 100 个字符的 `String` 运行 OQL 查询看起来如下：

```
select s from java.lang.String s where s.count >= 100

```

Show moreShow more icon

结果作为对象链接显示，然后展示该对象的完整内容，字段引用作为可以解除引用的其他链接的其他对象。OQL 查询同样可以调用对象的方法，将正则表达式作为查询的一部分，并使用内置查询工具。一种查询工具， `referrers()` 函数，显示了引用指定类型对象的所有引用。下面是寻找所有参考 `File` 对象的查询：

```
select referrers(f) from java.io.File f

```

Show moreShow more icon

您可以查找 OQL 的完整语法及其在 `jhat` 浏览器环境内 “OQL Help” 页面上的特性。将 `jhat` 与 OQL 相结合是对行为不当的堆进行对象调查的有效方法。

## 结束语

当您需要近距离观察 Java 进程内发生的事情时，JDK 的分析扩展会非常有用。本文中介绍的所有工具都可以从命令行中由其自己使用。它们还可以与 JConsole 或 VisualVM 有力地结合使用。JConsole 和 VisualVM 提供 Java 虚拟机的总体视图， `jstat` 和 `jmap` 等有针对性的工具支持您对研究进行微调。

尽管这些工具仍然是常用的，Java 7 引入了 JCMD 单一的实用程序，可以处理其他实用程序所做的许多事情。您可以使用它来识别 Java 进程 ID（类似于 `jps`），获得堆转储（类似于 `jmap`），制作线程转储（类似于 `jstack`），并生成垃圾收集统计数据（类似于 `jstat`）。

本文翻译自： [Java performance monitoring, Part 2](https://developer.ibm.com/articles/j-5things8/)（2010-07-13）